\section{\uppercase{Related work}}
\label{sec:relatedwork}
Code generation from state machines has received a lot of attention in automated software development. 
This section mentions some existing code generation patterns and how our approach differs. 
A systematic review of several proposals is presented in \cite{Domnguez2012}. 
%Main approaches including switch/if, state table and state pattern are investigated.

%Switch/if is the most intuitive technique implementing a "flat" state machine. Two types of switch/if are supported. The first one uses a scalar variable representing the current active state \cite{Booch1998}. A method for each event processes the variable as a discriminator in switch/if statement. The second one uses a double nested switch/if and has two variables to represent the current active state and the event to be processed \cite{Douglass1999}. The latter are used as the discriminators of an outer switch statement to select between states and an inner one/if statement to decide how the event should be processed. The behavior code of the two types is put in one file or class. This practice makes code cumbersome, complex, difficult to read and less explicit when the number of states grows or the state machine is hierarchical. Furthermore, the first approach lets the code scatter in different places. Therefore, maintaining or modifying such code of complex systems is very difficult.

Switch/if is the most intuitive technique for implementing a "flat" state machine. 
It either uses a scalar variable \cite{Booch1998} and a method for each event, or using two variables as the active state and the incoming event used as the discriminators of an outer switch statement to select between states and an inner one/if statement, respectively. 
The state table approach \cite{Douglass1999} uses one dimension for representing states and the other one for all possible events. 
These approaches require a transformation from hierarchical to flatten state machines. 
However, these approaches are hardly applied to state machines containing pseudo states such as deep history or join/fork.  
%Each cell of the table is associated with a function pointer meaning that the state associated with a dimension index of the cell is triggered by the event associated with the other dimension. 
%The behavior code of these techniques is put in one file or class. This practice makes code cumbersome, complex, difficult to read and less explicit when the number of states grows or the state machine is hierarchical. 
%Therefore, maintaining or modifying such code of complex systems is very difficult. 
%Furthermore, these approaches requires every transition must be triggered by at least an event. This is obviously only applied to a small sub-set of USMs.  

The object-oriented state pattern \cite{Shalyto2006,Douglass1999} transforms a state into a class and an event into a method. 
Events are processed by delegating from the class containing the state machine to its sub-state classes. 
Separation of states in classes makes the code more readable and maintainable. Unfortunately, this technique only supports flat state machines. 
This pattern is extended in \cite{niaz_mapping_2004} to support hierarchical state machines. 
Recently, a double-dispatch (DD) pattern presented in \cite{spinke_object-oriented_2013} extends \cite{niaz_mapping_2004} to support maintainability by %as a new technique to implement state machines. 
representing states and events as classes, and transitions as methods. 
However, as the results shown in \cite{spinke_object-oriented_2013}, these patterns require much memory because of an explosion of the number of classes and use dynamic memory allocation, which is not preferred in embedded systems.
%However, the maintenance of the code generated by this approach is not trivial since it requires many small changes in different places. %This is impractical when dealing with large state machines. %Furthermore, similar to the state table, this approach also poses the requirement of having at least one event for transition.
It is worth noting that none of these approaches provides implementation for all of state machine pseudo states as well as events.

Tools such as \cite{sparxsystems_enterprise_2014,ibm_rhapsody} apply different patterns to generate code. 
However, as mentioned in Section \ref{sec:intro}, true concurrency, some pseudo-states, and UML events are not supported. 
FXU \cite{Pilitowski2007} is the most complete tool but generated code is heavily dependent on their own library and C\# is generated.

Umple \cite{Badreddin2014} is a textual UML programming language, which supports code generation for different languages such as C++ and Java from state machines.
However, Umple does not support pseudo states such as fork, join, junction, and deep history, and local transitions.
Furthermore, only call events and time events are specified in Umple.

Our approach combines the classical switch/if pattern, to produce small footprint, and the pattern in \cite{niaz_mapping_2004}, to preserve state hierarchy.
Furthermore, we define pattern to transform all of USM concepts including states, pseudo states, transitions, and events.
Therefore, users are flexible to create there USM conforming to UML without restrictions.

%Our generation approach relies on and extends this approach. The latter profits the polymorphism of object-oriented languages. %provides some 1-1 mappings from state machines to object-oriented code and the implementation technique 
%is not dependent on a specific programming language. 
%However, DD does not deal with triggerless transitions and different event types supported by UML such as \ti{CallEvent}, \ti{TimeEvent} and \ti{SignalEvent}. Furthermore, DD is not a code generation approach but an approach to manually implementing state machines.